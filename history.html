<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Daniel GK Stats – Game History</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #121720;
      --muted: #8492a6;
      --text: #e8eefc;
      --accent: #3aa0ff;
      --shadow: 0 8px 30px rgba(0,0,0,.4);
      --radius: 16px;
      --pad: 14px;
    }

    html, body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
      margin: 0;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 16px;
    }

    h1, h2, h3 {
      margin: 0 0 10px;
    }

    .card {
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: var(--pad);
    }

    .stack {
      display: grid;
      gap: 12px;
    }

    label {
      font-size: 14px;
      color: var(--muted);
    }

    select {
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid #1f2733;
      background: #0f1520;
      color: var(--text);
      padding: 10px 12px;
      width: 100%;
      box-sizing: border-box;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #1f2733;
      background: #0f1520;
      font-size: 12px;
      color: var(--muted);
      gap: 6px;
    }

    .badge span.key {
      color: #9ca3af;
      font-weight: 600;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 12px;
    }

    .stat {
      background: #0f1520;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #1f2733;
      text-align: center;
    }

    .stat .v {
      font-size: 20px;
      font-weight: 800;
    }

    .stat .k {
      font-size: 12px;
      color: var(--muted);
    }

    .stat .sub {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }

    .shot-type-stats {
      margin-top: 8px;
      grid-template-columns: repeat(2, 1fr);
    }

    @media (min-width: 640px) {
      .shot-type-stats {
        grid-template-columns: repeat(4, 1fr);
      }
    }

    /* For shot-type tiles with data */
    .stat.muted-active {
      background: #151d2a;   /* more muted than the bright blue */
      border-color: #24324a;
    }

    .bars {
      display: grid;
      gap: 8px;
    }

    .bar {
      background: #0f1520;
      border-radius: 999px;
      border: 1px solid #1f2733;
      overflow: hidden;
      height: 16px;
    }

    .bar > div {
      height: 100%;
      background: var(--accent);
      width: 0%;
    }

    .legend {
      display: flex;
      justify-content: space-between;
      color: var(--muted);
      font-size: 12px;
    }

    .heat7 {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      background: #0b111b;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid #1f2733;
    }

    .heat7 .hc {
      aspect-ratio: 1/1;
      border-radius: 6px;
      border: 1px solid #1a2332;
      position: relative;
    }

    .heat7 .hc span {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #cbd5e1;
      mix-blend-mode: screen;
    }

    .heat {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      gap: 4px;
      background: #0b111b;
      padding: 8px;
      border-radius: 12px;
      border: 1px solid #1f2733;
    }

    .heat .hc {
      aspect-ratio: 1/1;
      border-radius: 6px;
      border: 1px solid #1a2332;
      position: relative;
    }

    .heat .hc span {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      color: #cbd5e1;
      mix-blend-mode: screen;
    }

    .muted { color: var(--muted); }
    .small { font-size: 12px; }
    .error { color: #fecaca; font-size: 14px; }

        /* Modal for heatmap cell details */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .6);
      display: none;
      align-items: flex-end;
      justify-content: center;
    }

    .modal.open {
      display: flex;
    }

    .sheet {
      background: var(--panel);
      width: 100%;
      max-width: 480px;
      border-radius: 16px;
      padding: 16px;
      margin: 16px;
      box-shadow: var(--shadow);
      max-height: 85vh;
      overflow: auto;
    }

    .btn {
      padding: 10px 12px;
      background: #0f1520;
      border: 1px solid #1f2733;
      border-radius: 12px;
      cursor: pointer;
      color: var(--text);
      font-size: 15px;
    }

    .btn.primary {
      background: var(--accent);
      color: #001e3c;
      border: none;
      font-weight: 600;
    }

    /* Legend for shot origin heatmap */
    .legend-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 6px;
      font-size: 12px;
      color: var(--muted);
      align-items: center;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 3px;
    }

    .legend-red    { background: rgba(255,100,100,1); }
    .legend-yellow { background: rgba(255,255,100,1); }
    .legend-green  { background: rgba(100,200,100,1); }
    .legend-blue   { background: rgba(58,160,255,1); }

    /* Heatmap Legend */
    .heat-legend {
      display: flex;
      gap: 16px;
      margin: 8px 0 18px;
      font-size: 13px;
      color: var(--muted);
      align-items: center;
    }
    
    .heat-legend div {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .legend-box {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      border: 1px solid #1a2332;
    }
    
    /* Matches your heatmap zone colors */
    
    .legend-box.outside {
      background: rgb(110,110,140);
    }
    
    .legend-box.frame {
      background: rgb(255,160,58);
    }
    
    .legend-box.goal {
      background: rgb(58,160,255);
    }

    @media (max-width: 400px) {
      .container { padding: 12px; }
      .card { padding: 12px; }
      .stats { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card stack">
      <h1>Daniel GK Stats – Game History</h1>

      <div class="stack">
        <div>
          <label for="gameSelect">Select game</label>
          <select id="gameSelect">
            <option value="">Loading…</option>
          </select>
        </div>
        <div id="metaRow" class="stack small muted"></div>
        <div id="error" class="error"></div>
      </div>

      <h2>Game Summary</h2>
      <div class="stats">
        <div class="stat">
          <div class="v" id="tSaves">0</div>
          <div class="k">Saves</div>
        </div>
        <div class="stat">
          <div class="v" id="tConceded">0</div>
          <div class="k">Conceded</div>
        </div>
        <div class="stat">
          <div class="v" id="tOff">0</div>
          <div class="k">Off Target</div>
        </div>
        <div class="stat">
          <div class="v" id="tSavePct">0%</div>
          <div class="k">Save %</div>
        </div>
      </div>

      <h3>Shot Types</h3>
      <div class="stats shot-type-stats" id="shotTypeStats"></div>

      <h3>Shot Origin Heatmap</h3>
      <div class="legend-row">
        <div class="legend-item">
          <span class="legend-swatch legend-red"></span>
          <span>6 yd box</span>
        </div>
        <div class="legend-item">
          <span class="legend-swatch legend-yellow"></span>
          <span>18 yd box</span>
        </div>
        <div class="legend-item">
          <span class="legend-swatch legend-green"></span>
          <span>Corner</span>
        </div>
        <div class="legend-item">
          <span class="legend-swatch legend-blue"></span>
          <span>Outside</span>
        </div>
      </div>
      <div class="heat7" id="originHeat"></div>

      <h3>Shot Heatmap</h3>
      <div class="heat" id="heat"></div>
      <div class="heat-legend">
        <div><span class="legend-box outside"></span> Outside</div>
        <div><span class="legend-box frame"></span> Frame</div>
        <div><span class="legend-box goal"></span> On Target</div>
      </div>

      <div class="small muted">
        Tip: “All games (combined)” aggregates every event returned by the API.
      </div>
    </div>
  </div>

  <!-- Heatmap Detail Modal -->
  <div id="heatmapModal" class="modal">
    <div class="sheet">
      <h3 id="hmTitle" style="text-align:center; margin-top:0;"></h3>
      <p id="hmBody" style="text-align:center; font-size:16px; margin:12px 0;"></p>
      <button id="hmClose" class="btn primary">Close</button>
    </div>
  </div>

  <script>
    const $  = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));

    // These keys match your original summary page
    const TYPE_KEYS = [
      'Open Play','Header','Free Kick',
      '1v1 – Challenged','1v1 – Stayed Back',
      'Corner – Inswing','Corner – Outswing',
      'PK – Regulation','PK – Shootout'
    ];

    let sessions = [];

    async function loadSessions() {
      const errorEl = $('#error');
      errorEl.textContent = '';
    
      try {
        // use your proxy (no CORS)
        const res = await fetch('/api/stats-proxy');
        if (!res.ok) throw new Error('HTTP ' + res.status);
    
        const data = await res.json();
        console.log('API raw data:', data);
    
        let parsed = [];
    
        // 1) If the JSON itself is an array
        if (Array.isArray(data)) {
          parsed = data;
        }
        // 2) Common container keys
        else if (Array.isArray(data.sessions)) {
          parsed = data.sessions;
        } else if (Array.isArray(data.data)) {
          parsed = data.data;
        } else if (Array.isArray(data.items)) {
          parsed = data.items;
        }
        // 3) Fallback: use all object values as sessions
        else if (data && typeof data === 'object') {
          const values = Object.values(data);
          if (values.length && typeof values[0] === 'object') {
            parsed = values;
          }
        }
    
        if (!parsed || !parsed.length) {
          throw new Error('Could not find sessions array in API response');
        }
    
        sessions = parsed;
    
        if (!sessions.length) {
          errorEl.textContent = 'No games found from API.';
          $('#gameSelect').innerHTML = '<option value="">No data</option>';
          return;
        }
    
        buildGameSelect();
        // default: all games combined
        $('#gameSelect').value = 'all';
        renderSummary();
      } catch (err) {
        console.error('loadSessions error:', err);
        errorEl.textContent = 'Error loading data from API. Check console for details.';
        $('#gameSelect').innerHTML = '<option value="">Error</option>';
      }
    }

    function buildGameSelect() {
      const sel = $('#gameSelect');
      sel.innerHTML = '';

      const allOpt = document.createElement('option');
      allOpt.value = 'all';
      allOpt.textContent = `All games (combined – ${sessions.length})`;
      sel.appendChild(allOpt);

      sessions.forEach((s, idx) => {
        const m = s.meta || {};
        const startedAt = m.startedAt ? new Date(m.startedAt) : null;
        const dateStr = startedAt
          ? startedAt.toLocaleString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'})
          : 'Unknown date';
        const label = `${dateStr} – ${m.team || 'Team ?'} vs ${m.opponent || 'Opponent ?'} (${m.pitch || 'Pitch ?'})`;

        const opt = document.createElement('option');
        opt.value = String(idx);
        opt.textContent = label;
        sel.appendChild(opt);
      });

      sel.addEventListener('change', renderSummary);
    }

    function renderSummary() {
      const selVal = $('#gameSelect').value;
      let events = [];
      let metaSummary = '';

      if (selVal === 'all') {
        sessions.forEach(s => {
          events = events.concat(s.events || []);
        });
        metaSummary = `All games – ${sessions.length} sessions`;
      } else {
        const idx = Number(selVal);
        const s = sessions[idx];
        if (!s) return;
        events = s.events || [];
        const m = s.meta || {};
        const dt = m.startedAt ? new Date(m.startedAt) : null;
        const dateStr = dt
          ? dt.toLocaleString(undefined, { year:'numeric', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'})
          : 'Unknown date';
        metaSummary = `${m.team || 'Team ?'} vs ${m.opponent || 'Opponent ?'} · ${m.pitch || 'Pitch ?'} · ${dateStr}`;
      }

      renderMeta(metaSummary);
      renderStatsAndCharts(events);
    }

    function renderMeta(text) {
      const row = $('#metaRow');
      row.innerHTML = '';
      if (!text) return;
      const div = document.createElement('div');
      div.textContent = text;
      row.appendChild(div);
    }

    function renderStatsAndCharts(events) {
      const saves = events.filter(e => e.result === 'Saved').length;
      const conceded = events.filter(e => e.result === 'Conceded').length;
      const off = events.filter(e => e.result === 'Off Target').length;
      const on = saves + conceded;
      const pct = on ? Math.round((saves / on) * 100) : 0;

      $('#tSaves').textContent = saves;
      $('#tConceded').textContent = conceded;
      $('#tOff').textContent = off;
      $('#tSavePct').textContent = pct + '%';

      // New shot-type tiles
      buildShotTypeStats(events);

      // Heatmaps
      buildOriginHeat('originHeat', events);
      buildHeat('heat', events);
      attachHeatmapClicks();
    }

    function buildBars(id, data) {
      const el = document.getElementById(id);
      el.innerHTML = '';
      const max = Math.max(1, ...data.map(x => x.count));
      data.forEach(({ label, count }) => {
        const wrap = document.createElement('div');
        const legend = document.createElement('div');
        legend.className = 'legend';
        legend.innerHTML = `<span>${label || '<i>Unspecified</i>'}</span><span>${count}</span>`;
        const bar = document.createElement('div');
        bar.className = 'bar';
        const inner = document.createElement('div');
        inner.style.width = `${(count / max) * 100}%`;
        bar.appendChild(inner);
        wrap.appendChild(legend);
        wrap.appendChild(bar);
        el.appendChild(wrap);
      });
    }

    function buildShotTypeStats(events) {
      const el = document.getElementById('shotTypeStats');
      if (!el) return;
      el.innerHTML = '';
    
      // Aggregate by shot type
      const stats = new Map();
      events.forEach(ev => {
        const key = ev.details?.shotType || '';
        if (!stats.has(key)) {
          stats.set(key, { total: 0, saved: 0, conceded: 0, off: 0 });
        }
        const s = stats.get(key);
        s.total++;
        if (ev.result === 'Saved') s.saved++;
        else if (ev.result === 'Conceded') s.conceded++;
        else if (ev.result === 'Off Target') s.off++;
      });
    
      // Render tiles in TYPE_KEYS order
      TYPE_KEYS.forEach(label => {
        const s = stats.get(label) || { total: 0, saved: 0, conceded: 0, off: 0 };
        const onTarget = s.saved + s.conceded;
        const pct = onTarget ? Math.round((s.saved / onTarget) * 100) : 0;
    
        const card = document.createElement('div');
        card.className = 'stat';
        if (s.total > 0) card.classList.add('muted-active');
    
        // for modal
        card.dataset.label = label || 'Unspecified';
        card.dataset.saved = s.saved;
        card.dataset.conceded = s.conceded;
        card.dataset.clickable = onTarget > 0 ? '1' : '0';
    
        const v = document.createElement('div');
        v.className = 'v';
        v.textContent = s.total;                // total shots of this type
    
        const k = document.createElement('div');
        k.className = 'k';
        k.textContent = label || 'Unspecified';
    
        const sub = document.createElement('div');
        sub.className = 'sub';
        sub.textContent = onTarget > 0 ? `${pct}% Save` : '';
    
        card.appendChild(v);
        card.appendChild(k);
        card.appendChild(sub);
        el.appendChild(card);
      });
    }

    function countBy(arr, fn, keys) {
      const m = new Map();
      arr.forEach(a => {
        const k = fn(a) || '';
        m.set(k, (m.get(k) || 0) + 1);
      });
      const rows = [];
      (keys || Array.from(m.keys())).forEach(k => rows.push({
        label: k,
        count: m.get(k) || 0
      }));
      if (!keys) rows.push({ label: '', count: m.get('') || 0 });
      return rows;
    }

    // --- Shot Origin Heatmap (3×7) – using % saved in each cell ---
    function buildOriginHeat(elId, events) {
      const el = document.getElementById(elId);
      el.innerHTML = '';

      const rows = 3, cols = 7;
      const savedCounts    = Array.from({ length: rows }, () => Array(cols).fill(0));
      const concededCounts = Array.from({ length: rows }, () => Array(cols).fill(0));
      const totalCounts    = Array.from({ length: rows }, () => Array(cols).fill(0));
      const posToLabel     = {};

      const labelToFirstPos = {
        'Corner – L':'r1c1','18yd – LW':'r1c2','6yd – Left':'r1c3','6yd – Center':'r1c4','6yd – Right':'r1c5','18yd – RW':'r1c6','Corner – R':'r1c7',
        'Outside – LW':'r2c1','18yd – L':'r2c3','18yd – C':'r2c4','18yd – R':'r2c5','Outside – RW':'r2c7',
        'Outside – L':'r3c2','Outside – C':'r3c4','Outside – R':'r3c5'
      };

      events.forEach(ev => {
        const label = ev.details?.origin || '';
        const pos = ev.details?.originPos || labelToFirstPos[label];
        if (!pos) return;
        const r = Number(pos[1]) - 1;
        const c = Number(pos[3]) - 1;
        if (r < 0 || r >= rows || c < 0 || c >= cols) return;

        if (ev.result === 'Saved')    savedCounts[r][c]++;
        if (ev.result === 'Conceded') concededCounts[r][c]++;
        if (ev.result === 'Saved' || ev.result === 'Conceded') {
          totalCounts[r][c]++;
          if (!posToLabel[pos]) posToLabel[pos] = label || pos;
        }
      });

      const max = Math.max(1, ...totalCounts.flat());

      const zoneRGBA = (r, c, alpha) => {
        if (r === 0 && (c === 2 || c === 3 || c === 4)) return `rgba(255,100,100,${alpha})`;
        if ((r === 0 && (c === 1 || c === 5)) || (r === 1 && c >= 1 && c <= 5)) return `rgba(255,255,100,${alpha})`;
        if (r === 0 && (c === 0 || c === 6)) return `rgba(100,200,100,${alpha})`;
        return `rgba(58,160,255,${alpha})`;
      };

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const total = totalCounts[r][c];
          const saved = savedCounts[r][c];

          const cell = document.createElement('div');
          cell.className = 'hc';

          const intensity = total / max;
          const a = 0.12 + intensity * 0.60;
          cell.style.background = zoneRGBA(r, c, a);

          const span = document.createElement('span');
          
          if (total > 0) {
            const pct = Math.round((saved / total) * 100);
            const conceded = total - saved;
            // first line: saved/conceded, second line: %
            span.innerHTML = `${saved}/${conceded}<br>${pct}%`;
          } else {
            span.textContent = '';
          }
          
          const key = `r${r+1}c${c+1}`;
          cell.dataset.label = posToLabel[key] || key;
          cell.dataset.saved = saved;
          cell.dataset.conceded = total - saved;
          
          cell.appendChild(span);
          el.appendChild(cell);
        }
      }
    }

    // --- Goal Location Heatmap – % saved per cell ---
    // --- Shot Heatmap – inside goal vs frame vs outside ---
    function buildHeat(id, events) {
      const el = document.getElementById(id);
      el.innerHTML = '';
    
      const rows = 5, cols = 9;
      const savedCount    = Array.from({ length: rows }, () => Array(cols).fill(0));
      const concededCount = Array.from({ length: rows }, () => Array(cols).fill(0));
      const totalCounts   = Array.from({ length: rows }, () => Array(cols).fill(0));
    
      const mapR = { Over:0, 'Top Bar':1, Top:2, Mid:3, Low:4 };
      const mapC = {
        'Left Outside':0,'Left Post':1,'Left':2,'Left Center':3,
        'Center':4,'Right Center':5,'Right':6,'Right Post':7,'Right Outside':8
      };
    
      // Tally events into grid
      events.forEach(ev => {
        const loc = ev.details?.location;
        if (!loc) return;
        const [row, col] = loc.split(' / ').map(s => s.trim());
        const r = mapR[row], c = mapC[col];
        if (r == null || c == null) return;
    
        if (ev.result === 'Saved')    savedCount[r][c]++;
        if (ev.result === 'Conceded') concededCount[r][c]++;
        if (ev.result === 'Saved' || ev.result === 'Conceded') totalCounts[r][c]++;
      });
    
      const max = Math.max(1, ...totalCounts.flat());
    
      // helper: classify cell as goal / frame / outside
      function getZone(r, c) {
        // Inside goal mouth: rows Top, Mid, Low; cols Left..Right (no posts/outside)
        const inGoal =
          r >= 2 && r <= 4 &&   // Top, Mid, Low
          c >= 2 && c <= 6;     // Left, Left Center, Center, Right Center, Right
    
        if (inGoal) return 'goal';
    
        // Goal frame: crossbar (Top Bar row) and posts (Left/Right Post cols)
        const isCrossbar = (r === 1 && c >= 1 && c <= 7);          // Top Bar across posts
        const isPosts    = ((c === 1 || c === 7) && r >= 2 && r <= 4); // vertical posts
    
        if (isCrossbar || isPosts) return 'frame';
    
        // Everything else = outside (over, left/right outside, etc.)
        return 'outside';
      }
    
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const total    = totalCounts[r][c];
          const saved    = savedCount[r][c];
          const conceded = concededCount[r][c];
    
          const d = document.createElement('div');
          d.className = 'hc';
    
          const zone = getZone(r, c);
          const intensity = total / max;
          const a = 0.10 + intensity * 0.55;
    
          // base colors for each zone
          let base;
          if (zone === 'goal') {
            base = [58, 160, 255];       // blue: shots in the goal mouth
          } else if (zone === 'frame') {
            base = [255, 160, 58];       // orange: bar and posts
          } else {
            base = [110, 110, 140];      // muted purple/grey: outside the goal
          }
    
          d.style.background = `rgba(${base[0]},${base[1]},${base[2]},${a})`;
    
          const s = document.createElement('span');
    
          if (total > 0) {
            const pct = Math.round((saved / total) * 100);
            s.innerHTML = `${saved}/${conceded}<br>${pct}%`;
          } else {
            s.textContent = '';
          }
    
          d.dataset.saved = saved;
          d.dataset.conceded = conceded;
          d.dataset.label =
            `${['Over','Top Bar','Top','Mid','Low'][r]} / ${
              ['Left Outside','Left Post','Left','Left Center','Center','Right Center','Right','Right Post','Right Outside'][c]
            }`;
    
          d.appendChild(s);
          el.appendChild(d);
        }
      }
    }

        /* ---------------- HEATMAP CLICK MODAL ---------------- */

    function attachHeatmapClicks() {
      const modal = document.getElementById('heatmapModal');
      const title = document.getElementById('hmTitle');
      const body = document.getElementById('hmBody');
      const close = document.getElementById('hmClose');

      if (!modal || !title || !body || !close) return;

      function handler(e) {
        const cell = e.currentTarget;
        const saved = Number(cell.dataset.saved || 0);
        const conceded = Number(cell.dataset.conceded || 0);
        const total = saved + conceded;

        if (!total) return; // nothing to show for empty tiles

        const pct = Math.round((saved / total) * 100);
        title.textContent = cell.dataset.label || 'Cell';
        body.textContent = `${saved} Saved · ${conceded} Conceded (${pct}% Saved)`;

        modal.classList.add('open');
      }

      // Remove old handlers by cloning nodes (in case we re-render)
      document.querySelectorAll('#originHeat .hc').forEach(cell => {
        const clone = cell.cloneNode(true);
        cell.replaceWith(clone);
        clone.addEventListener('click', handler);
      });

      document.querySelectorAll('#heat .hc').forEach(cell => {
        const clone = cell.cloneNode(true);
        cell.replaceWith(clone);
        clone.addEventListener('click', handler);
      });

      // Shot Type tiles
      document
        .querySelectorAll('#shotTypeStats .stat[data-clickable="1"]')
        .forEach(card => {
          const clone = card.cloneNode(true);
          card.replaceWith(clone);
          clone.addEventListener('click', handler);
        });

      close.onclick = () => modal.classList.remove('open');
      modal.onclick = e => {
        if (e.target === modal) modal.classList.remove('open');
      };
    }
    
    // kick things off
    loadSessions();
  </script>
</body>
</html>
